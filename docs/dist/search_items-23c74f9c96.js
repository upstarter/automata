searchNodes=[{"doc":"","ref":"Automata.html","title":"Automata","type":"module"},{"doc":"Callback implementation for Application.start/2.","ref":"Automata.html#start/2","title":"Automata.start/2","type":"function"},{"doc":"","ref":"Automata.html#start_agents/1","title":"Automata.start_agents/1","type":"function"},{"doc":"","ref":"Automata.html#status/1","title":"Automata.status/1","type":"function"},{"doc":"Parses each individual agent config from the user and starts it under the AgentSupervisor.","ref":"Automata.AgentServer.html","title":"Automata.AgentServer","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Automata.AgentServer.html#child_spec/1","title":"Automata.AgentServer.child_spec/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"Automata.AgentServer.html#init/1","title":"Automata.AgentServer.init/1","type":"function"},{"doc":"","ref":"Automata.AgentServer.html#init/2","title":"Automata.AgentServer.init/2","type":"function"},{"doc":"","ref":"Automata.AgentServer.html#start_link/1","title":"Automata.AgentServer.start_link/1","type":"function"},{"doc":"","ref":"Automata.AgentServer.html#status/1","title":"Automata.AgentServer.status/1","type":"function"},{"doc":"","ref":"Automata.AgentServer.State.html","title":"Automata.AgentServer.State","type":"module"},{"doc":"","ref":"Automata.AutomataSupervisor.html","title":"Automata.AutomataSupervisor","type":"module"},{"doc":"","ref":"Automata.AutomataSupervisor.html#child_spec/0","title":"Automata.AutomataSupervisor.child_spec/0","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Automata.AutomataSupervisor.html#child_spec/1","title":"Automata.AutomataSupervisor.child_spec/1","type":"function"},{"doc":"Callback implementation for DynamicSupervisor.init/1.","ref":"Automata.AutomataSupervisor.html#init/1","title":"Automata.AutomataSupervisor.init/1","type":"function"},{"doc":"","ref":"Automata.AutomataSupervisor.html#start_link/1","title":"Automata.AutomataSupervisor.start_link/1","type":"function"},{"doc":"Runs as a child of Automata.AutomataSupervisor and supervises the Automata.AgentServer which is a delegate for lifecycle management of the user agents and starts the agents under the Automata.AgentSupervisor. This supervisor uses strategy :one_for_all to ensure that errors restart the entire supervision tree including the Automaton.AgentServer.","ref":"Automata.AutomatonSupervisor.html","title":"Automata.AutomatonSupervisor","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Automata.AutomatonSupervisor.html#child_spec/1","title":"Automata.AutomatonSupervisor.child_spec/1","type":"function"},{"doc":"Callback implementation for Supervisor.init/1.","ref":"Automata.AutomatonSupervisor.html#init/1","title":"Automata.AutomatonSupervisor.init/1","type":"function"},{"doc":"","ref":"Automata.AutomatonSupervisor.html#start_link/1","title":"Automata.AutomatonSupervisor.start_link/1","type":"function"},{"doc":"A global Blackboard for knowledge representations","ref":"Automata.Blackboard.html","title":"Automata.Blackboard","type":"module"},{"doc":"Parallel Node When the execution of a parallel node starts, then the node’s children are executed in succession from left to right without waiting for a return status from any child before ticking the next one. It returns success if a given number of children M ∈ N return success, it returns failure when the children that return running and success are not enough to reach the given number, even if they would all return success. It returns running otherwise. The purpose of the parallel node is to model those tasks separable in independent sub-tasks performing non-conflicting actions (e.g. a multi object tracking can be performed using several cameras). We could also configure Parallel to have the policy of the Selector task so it returns success when its first child succeeds and failure only when all have failed. We could also use hybrid policies, where it returns success or failure after some specific number or proportion of its children have succeeded or failed. Using Parallel blocks to make sure that Conditions hold is an important use-case in behavior trees. With it we can get much of the power of a state machine, and in particular the state machine’s ability to switch tasks when important events occur and new opportunities arise. Rather than events triggering transitions between states, we can use sub-trees as states and have them running in parallel with a set of conditions.","ref":"Automaton.Types.BT.Composite.Parallel.html","title":"Automaton.Types.BT.Composite.Parallel","type":"module"},{"doc":"Handles lifecycle of Automata.AutomataSupervisor as a delegate to keep the supervisor lean and mean, since it handles each Automata.AutomatonSupervisor, passing the user config, which flows through the entire tree. This data flow is a key abstraction for the agents.","ref":"Automata.Server.html","title":"Automata.Server","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Automata.Server.html#child_spec/1","title":"Automata.Server.child_spec/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"Automata.Server.html#init/1","title":"Automata.Server.init/1","type":"function"},{"doc":"","ref":"Automata.Server.html#start_link/1","title":"Automata.Server.start_link/1","type":"function"},{"doc":"","ref":"Automata.Server.html#status/1","title":"Automata.Server.status/1","type":"function"},{"doc":"On application start, this supervisor process starts the AutomataSupervisor and it&#39;s corresponding Server. It is started with strategy :one_for_one to ensure that each AutomatonSupervisor is independently self-healing, thus providing fault tolerant decentralization.","ref":"Automata.Supervisor.html","title":"Automata.Supervisor","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Automata.Supervisor.html#child_spec/1","title":"Automata.Supervisor.child_spec/1","type":"function"},{"doc":"Callback implementation for Supervisor.init/1.","ref":"Automata.Supervisor.html#init/1","title":"Automata.Supervisor.init/1","type":"function"},{"doc":"","ref":"Automata.Supervisor.html#start_link/1","title":"Automata.Supervisor.start_link/1","type":"function"},{"doc":"Global utility decisioning First pass should prioritize automata based on global utility calculations Second pass should coordinate automata in achievement of some global goal","ref":"Automata.Utility.html","title":"Automata.Utility","type":"module"},{"doc":"","ref":"Automata.World.html","title":"Automata.World","type":"module"},{"doc":"This is the primary user control interface to the Automata system. The configration parameters are used to inject the appropriate modules into the user-defined nodes based on their node_type and other options. ## Notes: - Initialization and shutdown require extra care: - on_init: receive extra parameters, fetch data from blackboard/utility, make requests, etc.. - shutdown: free resources to not effect other actions TODO: store any currently processing nodes so they can be ticked directly within the behaviour tree engine rather than per tick traversal of the entire tree. Zipper Tree?","ref":"Automaton.html","title":"Automaton","type":"module"},{"doc":"An action is a leaf in the tree. It operates on the world as a component of a composite(control) node.","ref":"Automaton.Types.BT.Action.html","title":"Automaton.Types.BT.Action","type":"module"},{"doc":"Directly supervises the lifecycle of the user-defined agents (behavior trees). The Automaton.AgentServer starts them under this process. It is the parent and root of the user-defined composite.","ref":"Automaton.AgentSupervisor.html","title":"Automaton.AgentSupervisor","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Automaton.AgentSupervisor.html#child_spec/1","title":"Automaton.AgentSupervisor.child_spec/1","type":"function"},{"doc":"Callback implementation for DynamicSupervisor.init/1.","ref":"Automaton.AgentSupervisor.html#init/1","title":"Automaton.AgentSupervisor.init/1","type":"function"},{"doc":"","ref":"Automaton.AgentSupervisor.html#start_link/1","title":"Automaton.AgentSupervisor.start_link/1","type":"function"},{"doc":"An Automaton.Types.BT.Behavior is an abstract interface for composites and components that can be activated, run, and deactivated. Actions(Execution Nodes) provide specific implementations of this interface. Branches in the tree can be thought of as high level behaviors, heirarchically combining smaller behaviors to provide more complex and interesting behaviors. Note: there is a bunch of placeholder stuff in here right now and needs thought and cleanup. The specs for the callbacks are not accurate, just needed something that compiled and ran. Needs more thought and attention as the design process continues.","ref":"Automaton.Types.BT.Behavior.html","title":"Automaton.Types.BT.Behavior","type":"behaviour"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:abort/0","title":"Automaton.Types.BT.Behavior.abort/0","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:aborted?/0","title":"Automaton.Types.BT.Behavior.aborted?/0","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:on_init/1","title":"Automaton.Types.BT.Behavior.on_init/1","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:on_terminate/1","title":"Automaton.Types.BT.Behavior.on_terminate/1","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:reset/0","title":"Automaton.Types.BT.Behavior.reset/0","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:running?/0","title":"Automaton.Types.BT.Behavior.running?/0","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:status/0","title":"Automaton.Types.BT.Behavior.status/0","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:terminated?/0","title":"Automaton.Types.BT.Behavior.terminated?/0","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:update/1","title":"Automaton.Types.BT.Behavior.update/1","type":"callback"},{"doc":"The Node Blackboard Blackboard Architectures A blackboard system isn’t a decision making tool in its own right. It is a mechanism for coordinating the actions of several decision makers. The individual decision making systems can be implemented in any way: from a decision tree to an expert system or even to learning tools such as neural networks. It is this flexibility that makes blackboard architectures appealing. The Problem We would like to be able to coordinate the decision making of several different techniques. Each technique may be able to make suggestions as to what to do next, but the final decision can only be made if they cooperate. The Blackboard Metaphor Blackboard-based problem solving is often presented using the following metaphor: Imagine a group of human specialists seated next to a large blackboard. The specialists are working cooperatively to solve a problem, using the blackboard as the workplace for developing the solution. Problem solving begins when the problem and initial data are written onto the blackboard. The specialists watch the blackboard, looking for an opportunity to apply their expertise to the developing solution. When a specialist finds sufficient information to make a contribution, she records the contribution on the blackboard, hopefully enabling other specialists to apply their expertise. This process of adding contributions to the blackboard continues until the problem has been solved. This simple metaphor captures a number of the important characteristics of blackboard systems, each of which is described separately below. - Independence of expertise (I think, therefore I am.) - Diversity in problem-solving techniques (I don’t think like you do.) - Flexible representation of blackboard information (If you can draw it, I can use it.) - Common interaction language (What’d you say?) - Positioning metrics (You could look it up.) If the problem being solved by our human specialists is complex and the number of their contributions made on the blackboard begins to grow, quickly locating pertinent information becomes a problem. A specialist should not have to scan the entire blackboard to see if a particular item has been placed on the blackboard by another specialist. One solution is to subdivide the blackboard into regions, each corresponding to a particular kind of information. This approach is commonly used in blackboard systems, where different levels, planes, or multiple blackboards are used to group related objects. Similarly, ordering metrics can be used within each region, to sort information numerically, alphabetically, or by relevance. Advanced blackboard-system frameworks provide sophisticated multidimensional metrics for efficiently locating blackboard objects of interest. - Event-based activation (Is anybody there?) - Need for control (It’s my turn.) - Incremental solution generation (Step by step, inch by inch. . .)","ref":"Automaton.Blackboard.html","title":"Automaton.Blackboard","type":"module"},{"doc":"When a component behavior is complete and returns its status code, then the Composite it is a child of decides whether to continue through its children or whether to stop there and then and return a value. Supervised by the Automaton.Types.BT.CompositeServer which is the parent of the component.","ref":"Automaton.Types.BT.ComponentServer.html","title":"Automaton.Types.BT.ComponentServer","type":"module"},{"doc":"","ref":"Automaton.Types.BT.ComponentServer.html#types/0","title":"Automaton.Types.BT.ComponentServer.types/0","type":"function"},{"doc":"Selector Node (also known as Fallback) When the execution of a selector node starts, the node’s children are executed in succession from left to right, until a child returning success or running is found. Then this message is returned to the parent of the selector. It returns failure only when all the children return a status failure. The purpose of the selector node is to robustly carry out a task that can be performed using several different approaches. A Selector will return immediately with a success status code when one of its children runs successfully. As long as its children are failing, it will keep on trying. If it runs out of children completely, it will return a failure status code.","ref":"Automaton.Types.BT.Composite.Selector.html","title":"Automaton.Types.BT.Composite.Selector","type":"module"},{"doc":"Behavior for user-defined sequence actions. When the execution of a sequence node starts, then the node’s children are executed in succession from left to right, returning to its parent a status failure (or running) as soon as a child that returns failure (or running) is found. It returns success only when all the children return success. The purpose of the sequence node is to carry out the tasks that are deﬁned by a strict sequence of sub-tasks, in which all have to succeed. A Sequence will return immediately with a failure status code when one of its children fails. As long as its children are succeeding, it will keep going. If it runs out of children, it will return in success.","ref":"Automaton.Types.BT.Composite.Sequence.html","title":"Automaton.Types.BT.Composite.Sequence","type":"module"},{"doc":"When a child behavior is complete and returns its status code the Composite decides whether to continue through its children or whether to stop there and then and return a value. The behavior tree represents all possible Actions that your AI can take. The route from the top level to each leaf represents one course of action, and the behavior tree algorithm traverses among those courses of action in a left-to-right manner. In other words, it performs a depth-first traversal.","ref":"Automaton.Types.BT.CompositeServer.html","title":"Automaton.Types.BT.CompositeServer","type":"behaviour"},{"doc":"","ref":"Automaton.Types.BT.CompositeServer.html#c:add_child/1","title":"Automaton.Types.BT.CompositeServer.add_child/1","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.CompositeServer.html#c:clear_children/0","title":"Automaton.Types.BT.CompositeServer.clear_children/0","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.CompositeServer.html#c:continue_status/0","title":"Automaton.Types.BT.CompositeServer.continue_status/0","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.CompositeServer.html#c:remove_child/1","title":"Automaton.Types.BT.CompositeServer.remove_child/1","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.CompositeServer.html#types/0","title":"Automaton.Types.BT.CompositeServer.types/0","type":"function"},{"doc":"The CompositeServer is injected into the user-defined automaton and manages the lifecycle of their agents, ie. starting, stopping, and handling messages. All components are children of a composite.","ref":"Automaton.Types.BT.CompositeSupervisor.html","title":"Automaton.Types.BT.CompositeSupervisor","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Automaton.Types.BT.CompositeSupervisor.html#child_spec/1","title":"Automaton.Types.BT.CompositeSupervisor.child_spec/1","type":"function"},{"doc":"Callback implementation for DynamicSupervisor.init/1.","ref":"Automaton.Types.BT.CompositeSupervisor.html#init/1","title":"Automaton.Types.BT.CompositeSupervisor.init/1","type":"function"},{"doc":"","ref":"Automaton.Types.BT.CompositeSupervisor.html#start_link/1","title":"Automaton.Types.BT.CompositeSupervisor.start_link/1","type":"function"},{"doc":"Purely Functional high level parsing policy for automaton type specific config from user_config. User Provided State Space parsing &amp; interpretation boundary point Delegate provided user input to modules corresponding to config state spaces","ref":"Automaton.Config.Parser.html","title":"Automaton.Config.Parser","type":"module"},{"doc":"Determines the node_type given the user_config. Returns node_type. Examples iex&gt; user_config = [node_type: :selector] iex&gt; Automaton.Config.Parser.node_type(user_config) :selector","ref":"Automaton.Config.Parser.html#node_type/1","title":"Automaton.Config.Parser.node_type/1","type":"function"},{"doc":"Implements the BT state space representation.","ref":"Automaton.Types.BT.html","title":"Automaton.Types.BT","type":"module"},{"doc":"","ref":"Automaton.Types.Typology.html","title":"Automaton.Types.Typology","type":"module"},{"doc":"","ref":"Automaton.Types.Typology.html#call/1","title":"Automaton.Types.Typology.call/1","type":"function"},{"doc":"","ref":"Automaton.Types.Typology.html#types/0","title":"Automaton.Types.Typology.types/0","type":"function"},{"doc":"Node utility decisioning First pass should prioritize composite &#39;selector&#39; actions based on utility (a priority composite node) Dual Utility Reasoner? There are two common approaches to utility-based selection. The first, absolute utility, is to evaluate every option and take the one with the highest utility. The second, relative utility, is to select an option at random, using the utility of each option to define the probability that it will be selected. The probability (P) for selecting an option (O) is determined by dividing the utility (U) of that option by the total utility of all options. This approach is commonly referred to as weight-based random or weighted random. A Dual Utility Reasoner combines both of these approaches. It assigns two utility values to each option: a rank (absolute utility) and a weight (relative utility). Conceptually, rank is used to divide the options into categories, where we only select options that are in the best category. Weight is used to evaluate options within the context of their category. Thus the weight of an option is only meaningful relative to the weights of other options within the same rank category – and only the weights of the options in the best category truly matter","ref":"Automaton.Utility.html","title":"Automaton.Utility","type":"module"},{"doc":"","ref":"MockSeq1.html","title":"MockSeq1","type":"module"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.abort/0.","ref":"MockSeq1.html#abort/0","title":"MockSeq1.abort/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.aborted?/0.","ref":"MockSeq1.html#aborted?/0","title":"MockSeq1.aborted?/0","type":"function"},{"doc":"","ref":"MockSeq1.html#add_child/1","title":"MockSeq1.add_child/1","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"MockSeq1.html#child_spec/1","title":"MockSeq1.child_spec/1","type":"function"},{"doc":"","ref":"MockSeq1.html#clear_children/0","title":"MockSeq1.clear_children/0","type":"function"},{"doc":"","ref":"MockSeq1.html#continue_status/0","title":"MockSeq1.continue_status/0","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"MockSeq1.html#init/1","title":"MockSeq1.init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_init/1.","ref":"MockSeq1.html#on_init/1","title":"MockSeq1.on_init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_terminate/1.","ref":"MockSeq1.html#on_terminate/1","title":"MockSeq1.on_terminate/1","type":"function"},{"doc":"","ref":"MockSeq1.html#remove_child/1","title":"MockSeq1.remove_child/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.reset/0.","ref":"MockSeq1.html#reset/0","title":"MockSeq1.reset/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.running?/0.","ref":"MockSeq1.html#running?/0","title":"MockSeq1.running?/0","type":"function"},{"doc":"","ref":"MockSeq1.html#schedule_next_tick/1","title":"MockSeq1.schedule_next_tick/1","type":"function"},{"doc":"","ref":"MockSeq1.html#set_status/2","title":"MockSeq1.set_status/2","type":"function"},{"doc":"","ref":"MockSeq1.html#start_children/1","title":"MockSeq1.start_children/1","type":"function"},{"doc":"","ref":"MockSeq1.html#start_link/1","title":"MockSeq1.start_link/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.status/0.","ref":"MockSeq1.html#status/0","title":"MockSeq1.status/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.terminated?/0.","ref":"MockSeq1.html#terminated?/0","title":"MockSeq1.terminated?/0","type":"function"},{"doc":"","ref":"MockSeq1.html#tick/1","title":"MockSeq1.tick/1","type":"function"},{"doc":"","ref":"MockSeq1.html#tick_workers/1","title":"MockSeq1.tick_workers/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.update/1.","ref":"MockSeq1.html#update/1","title":"MockSeq1.update/1","type":"function"},{"doc":"","ref":"MockSeq1.State.html","title":"MockSeq1.State","type":"module"},{"doc":"","ref":"Seq1.html","title":"Seq1","type":"module"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.abort/0.","ref":"Seq1.html#abort/0","title":"Seq1.abort/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.aborted?/0.","ref":"Seq1.html#aborted?/0","title":"Seq1.aborted?/0","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Seq1.html#child_spec/1","title":"Seq1.child_spec/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"Seq1.html#init/1","title":"Seq1.init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_init/1.","ref":"Seq1.html#on_init/1","title":"Seq1.on_init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_terminate/1.","ref":"Seq1.html#on_terminate/1","title":"Seq1.on_terminate/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.reset/0.","ref":"Seq1.html#reset/0","title":"Seq1.reset/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.running?/0.","ref":"Seq1.html#running?/0","title":"Seq1.running?/0","type":"function"},{"doc":"","ref":"Seq1.html#schedule_next_tick/1","title":"Seq1.schedule_next_tick/1","type":"function"},{"doc":"","ref":"Seq1.html#set_status/2","title":"Seq1.set_status/2","type":"function"},{"doc":"","ref":"Seq1.html#start_link/1","title":"Seq1.start_link/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.status/0.","ref":"Seq1.html#status/0","title":"Seq1.status/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.terminated?/0.","ref":"Seq1.html#terminated?/0","title":"Seq1.terminated?/0","type":"function"},{"doc":"","ref":"Seq1.html#tick/1","title":"Seq1.tick/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.update/1.","ref":"Seq1.html#update/1","title":"Seq1.update/1","type":"function"},{"doc":"","ref":"Seq1.State.html","title":"Seq1.State","type":"module"},{"doc":"","ref":"Seq2.html","title":"Seq2","type":"module"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.abort/0.","ref":"Seq2.html#abort/0","title":"Seq2.abort/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.aborted?/0.","ref":"Seq2.html#aborted?/0","title":"Seq2.aborted?/0","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Seq2.html#child_spec/1","title":"Seq2.child_spec/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"Seq2.html#init/1","title":"Seq2.init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_init/1.","ref":"Seq2.html#on_init/1","title":"Seq2.on_init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_terminate/1.","ref":"Seq2.html#on_terminate/1","title":"Seq2.on_terminate/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.reset/0.","ref":"Seq2.html#reset/0","title":"Seq2.reset/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.running?/0.","ref":"Seq2.html#running?/0","title":"Seq2.running?/0","type":"function"},{"doc":"","ref":"Seq2.html#schedule_next_tick/1","title":"Seq2.schedule_next_tick/1","type":"function"},{"doc":"","ref":"Seq2.html#set_status/2","title":"Seq2.set_status/2","type":"function"},{"doc":"","ref":"Seq2.html#start_link/1","title":"Seq2.start_link/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.status/0.","ref":"Seq2.html#status/0","title":"Seq2.status/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.terminated?/0.","ref":"Seq2.html#terminated?/0","title":"Seq2.terminated?/0","type":"function"},{"doc":"","ref":"Seq2.html#tick/1","title":"Seq2.tick/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.update/1.","ref":"Seq2.html#update/1","title":"Seq2.update/1","type":"function"},{"doc":"","ref":"Seq2.State.html","title":"Seq2.State","type":"module"},{"doc":"","ref":"Seq3.html","title":"Seq3","type":"module"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.abort/0.","ref":"Seq3.html#abort/0","title":"Seq3.abort/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.aborted?/0.","ref":"Seq3.html#aborted?/0","title":"Seq3.aborted?/0","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Seq3.html#child_spec/1","title":"Seq3.child_spec/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"Seq3.html#init/1","title":"Seq3.init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_init/1.","ref":"Seq3.html#on_init/1","title":"Seq3.on_init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_terminate/1.","ref":"Seq3.html#on_terminate/1","title":"Seq3.on_terminate/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.reset/0.","ref":"Seq3.html#reset/0","title":"Seq3.reset/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.running?/0.","ref":"Seq3.html#running?/0","title":"Seq3.running?/0","type":"function"},{"doc":"","ref":"Seq3.html#schedule_next_tick/1","title":"Seq3.schedule_next_tick/1","type":"function"},{"doc":"","ref":"Seq3.html#set_status/2","title":"Seq3.set_status/2","type":"function"},{"doc":"","ref":"Seq3.html#start_link/1","title":"Seq3.start_link/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.status/0.","ref":"Seq3.html#status/0","title":"Seq3.status/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.terminated?/0.","ref":"Seq3.html#terminated?/0","title":"Seq3.terminated?/0","type":"function"},{"doc":"","ref":"Seq3.html#tick/1","title":"Seq3.tick/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.update/1.","ref":"Seq3.html#update/1","title":"Seq3.update/1","type":"function"},{"doc":"","ref":"Seq3.State.html","title":"Seq3.State","type":"module"},{"doc":"","ref":"Seq4.html","title":"Seq4","type":"module"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.abort/0.","ref":"Seq4.html#abort/0","title":"Seq4.abort/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.aborted?/0.","ref":"Seq4.html#aborted?/0","title":"Seq4.aborted?/0","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Seq4.html#child_spec/1","title":"Seq4.child_spec/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"Seq4.html#init/1","title":"Seq4.init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_init/1.","ref":"Seq4.html#on_init/1","title":"Seq4.on_init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_terminate/1.","ref":"Seq4.html#on_terminate/1","title":"Seq4.on_terminate/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.reset/0.","ref":"Seq4.html#reset/0","title":"Seq4.reset/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.running?/0.","ref":"Seq4.html#running?/0","title":"Seq4.running?/0","type":"function"},{"doc":"","ref":"Seq4.html#schedule_next_tick/1","title":"Seq4.schedule_next_tick/1","type":"function"},{"doc":"","ref":"Seq4.html#set_status/2","title":"Seq4.set_status/2","type":"function"},{"doc":"","ref":"Seq4.html#start_link/1","title":"Seq4.start_link/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.status/0.","ref":"Seq4.html#status/0","title":"Seq4.status/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.terminated?/0.","ref":"Seq4.html#terminated?/0","title":"Seq4.terminated?/0","type":"function"},{"doc":"","ref":"Seq4.html#tick/1","title":"Seq4.tick/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.update/1.","ref":"Seq4.html#update/1","title":"Seq4.update/1","type":"function"},{"doc":"","ref":"Seq4.State.html","title":"Seq4.State","type":"module"},{"doc":"","ref":"SeqComposite1.html","title":"SeqComposite1","type":"module"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.abort/0.","ref":"SeqComposite1.html#abort/0","title":"SeqComposite1.abort/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.aborted?/0.","ref":"SeqComposite1.html#aborted?/0","title":"SeqComposite1.aborted?/0","type":"function"},{"doc":"","ref":"SeqComposite1.html#add_child/1","title":"SeqComposite1.add_child/1","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"SeqComposite1.html#child_spec/1","title":"SeqComposite1.child_spec/1","type":"function"},{"doc":"","ref":"SeqComposite1.html#clear_children/0","title":"SeqComposite1.clear_children/0","type":"function"},{"doc":"","ref":"SeqComposite1.html#continue_status/0","title":"SeqComposite1.continue_status/0","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"SeqComposite1.html#init/1","title":"SeqComposite1.init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_init/1.","ref":"SeqComposite1.html#on_init/1","title":"SeqComposite1.on_init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_terminate/1.","ref":"SeqComposite1.html#on_terminate/1","title":"SeqComposite1.on_terminate/1","type":"function"},{"doc":"","ref":"SeqComposite1.html#remove_child/1","title":"SeqComposite1.remove_child/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.reset/0.","ref":"SeqComposite1.html#reset/0","title":"SeqComposite1.reset/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.running?/0.","ref":"SeqComposite1.html#running?/0","title":"SeqComposite1.running?/0","type":"function"},{"doc":"","ref":"SeqComposite1.html#schedule_next_tick/1","title":"SeqComposite1.schedule_next_tick/1","type":"function"},{"doc":"","ref":"SeqComposite1.html#set_status/2","title":"SeqComposite1.set_status/2","type":"function"},{"doc":"","ref":"SeqComposite1.html#start_children/1","title":"SeqComposite1.start_children/1","type":"function"},{"doc":"","ref":"SeqComposite1.html#start_link/1","title":"SeqComposite1.start_link/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.status/0.","ref":"SeqComposite1.html#status/0","title":"SeqComposite1.status/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.terminated?/0.","ref":"SeqComposite1.html#terminated?/0","title":"SeqComposite1.terminated?/0","type":"function"},{"doc":"","ref":"SeqComposite1.html#tick/1","title":"SeqComposite1.tick/1","type":"function"},{"doc":"","ref":"SeqComposite1.html#tick_workers/1","title":"SeqComposite1.tick_workers/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.update/1.","ref":"SeqComposite1.html#update/1","title":"SeqComposite1.update/1","type":"function"},{"doc":"","ref":"SeqComposite1.State.html","title":"SeqComposite1.State","type":"module"},{"doc":"⦿ | Automata | ⦿ ⦿ ⦿ ⦿ Spawn a system of concurrent, distributed, fault tolerant, and highly available intelligent agents for coordinated and/or uncoordinated action in one or many environments with no central point of failure. This project is Open Source.","ref":"readme.html","title":"ReadMe","type":"extras"},{"doc":"The Automata Project combines the state-of-the-art AI control techniques with the latest research in autonomous decentralized systems, providing AI designers a flexible framework for creating valuable emergent properties in product ecosystems. This project is in the Alpha stage and not ready for production systems. We need Contributors to get to 1.0. We are eager for your contributions and very happy you found yourself here! Please join the slack channel and/or reach out to ericsteen1@gmail.com if interested or with any questions. Here are our contributing guidelines and get up to speed on the wiki.","ref":"readme.html#project-mission","title":"ReadMe - Project Mission","type":"extras"},{"doc":"Note: This will be updated often. The direction of the project will change as the work evolves. We very eagerly welcome any of your thoughts about roadmapping See the current milestones here.","ref":"readme.html#roadmap","title":"ReadMe - Roadmap","type":"extras"},{"doc":"Testing is currently happening using the mock sequence in worlds/mock_world_1/mock_automata/mock_seq_1.ex. This is currently our canonical example of how to design one automaton, which is a behavior tree, and eventually communicates with others that you define in worlds/&lt;mock_world&gt;/&lt;mock_automata&gt;/&lt;mock_bt&gt;. Currently, you can run the mock sequence in an iex shell as follows: iex -S mix iex(1)&gt; send(MockSeq1Server, :update) and tests can be run with debugging capabilities as follows: MIX_ENV=test iex -S mix espec spec/unit/core/behavior_test.exs:31 where you are running a specific context/it block containing line 31.","ref":"readme.html#usage","title":"ReadMe - Usage","type":"extras"},{"doc":"Technologies Elixir &amp; OTP provide the primitives for robust concurrent, fault-tolerant, highly available, self-healing distributed systems. Based on the Actor Model 1, a singular Elixir Process(Actor) embodies all 3 essential elements of computation: processing, storage, communications. It does so using very lightweight, isolated processes, each with its own stack, heap, communications facilities (mailbox), and garbage collector. The Erlang VM (BEAM), with pre-emptive scheduling, acts somewhat as on operating system on top of an operating system. Pre-emption is good because it prevents bad actors from starving the rest of the system, allowing for higher degrees of concurrency and better interactive performance. Behavior Trees are increasingly used in place of finite state machines (FSM&#39;s) and other AI control architectures due to improved properties of modularity, flexibility, reusability, and efficiency of implementation. They enable design/development scalability and efficiency. Utility AI is used to keep the automata focused on actions by providing an external system for all decision making support. This significantly reduces the amount of logic/nodes required for an agent and takes the heavy mathematical workload off of designers &amp; action developers. Read the wiki and/or the docs for more about the technologies underlying Automata. Requirements Autonomy is the capacity of agent(s) to achieve a set of coordinated goals by their own means (without human intervention) adapting to environment variations. It combines five complementary aspects: Perception e.g. interpretation of stimuli, removing ambiguity/vagueness from complex input data and determining relevant information based on context/strata/motif specific communications Reflection e.g. building/updating a faithful environment run-time model Goal management e.g. choosing among possible goals the most appropriate ones for a given configuration of the environment model Planning to achieve chosen goals Self-adaptation e.g. the ability to adjust behavior through learning and reasoning and to change dynamically the goal management and planning processes. Note that the five aspects are orthogonal. The first two aspects deal with “understanding” the map of the environment. The third and the forth aspects deal with autonomy of decision. Self adaptation ensures adequacy of decisions with respect to the environment map. See MMLC2. A system is defined as an Autonomous Decentralized System (ADS) if the following 2 properties are satisfied: Autonomous Controllability: Even if any subsystem fails, is repaired, and/or is newly added, the other subsystems can continue to manage themselves and function. Autonomous Coordinability: Even if any subsystem fails, is repaired, and/or is newly added, the other subsystems can coordinate their individual objectives among themselves and can function in a coordinated fashion.","ref":"readme.html#implementation-overview","title":"ReadMe - Implementation Overview","type":"extras"},{"doc":"Functional Features: General User defined behavior trees Control Nodes currently on the roadmap Selector Sequence Parallel Priority Condition nodes In-node Decorators Helper Nodes for accessing utility AI systems A Concurrent, Scalable Blackboard Knowledge System The central problem of artificial intelligence is how to express the knowledge needed in order to create intelligent behavior. — John McCarthy, M.I.T/Stanford Professor, Creator of Lisp A global blackboard that can coordinate automata without being a central point of failure. Individual automaton blackboards readable by all automata, writeable by owning automaton Meta Level Control Meta-level control (triggered each heartbeat) to support agent interaction, any potential network reorganization. Meta-level control is the ability of an agent to optimize its long term performance by choosing and sequencing its deliberation and execution actions appropriately. 2 Neuromorphic/Probabilistic computing potentially bringing the code to the data rather than the other way around. Performance Features: Concurrency The world is concurrent. For example: we see, hear, and move at the same time. Many global financial instruments are fluctuating at this instance. Concurrency was a core factor in the design of Erlang, making it easy to reason about and debug. High availability Elixir is capable of 99.9999999% uptime (31 milliseconds/year of downtime). The main point of the Erlang model is an application that can be expected to run forever, as stated by the inventor — Joe Armstrong (RIP). Talk about unstoppable software! Fault Tolerance OTP Supervision Trees and the &quot;fail fast&quot; principle provide strong guarantees for error recovery and self healing systems. Scalability &amp; Distribution Elixir can handle millions of processes (134 million +/-) utilizing all cores without breaking a sweat on a single machine, and easily distributes work onto multiple machines with its builtin distribution mechanisms, and there is CRDT support with Horde. Behavior trees provide value chain efficiency/scalability (in both design/development and operations/testing) compared to previous state of the art AI control techniques. Modularity Modular BT&#39;s allow the designer to hierarchically combine independently developed, tested, deployed, and reusable unit behaviors that provide more valuable emergent properties in the large. Flexibility A design goal of Automata is to allow high flexibility via extreme abstraction (to enable design space evolution, support diversity in applications) Simplicity of Implementation Elixir&#39;s meta-programming facilities enable very user-friendly API&#39;s so developers don&#39;t need to know the details of BT&#39;s or Automata Theory to get things done, and BT&#39;s themselves lend efficiency to the development value chain. Applications Trading Systems Patient Monitoring &amp; Care Systems Autonomous Pandemic Testing Drone Units Swarm Intelligence / Distributed Robotics Intelligent agents with soft realtime multi-dimensional sensory, perception, intuition, and action capabilities Multi-Agent Reinforcement Learning Mixture of Experts Deep Learning Control Systems (python inter-op with erlport) Blockchain Smart Contract Systems A Mega-constellation of satellites 3D Printing and Factory Automation Product Analytics Systems Augmented, Virtual, Mixed Reality Smart Home / IOT Systems High-Speed Rail Systems (Japan has an ADS railway that learns) Chatbot &amp; Game AI&#39;s (esp. MMOG user/npc backends) QA Testing (BT&#39;s are particularly suited to combinatorial testing) ? (choose your adventure) API Users create worlds containing their automata in directory structures corresponding to their BT tree structures. These are created in the worlds/ directory. Trees can be of arbitrary depth. Users define their own custom modules which use Automaton as a macro. By overriding the update() function and returning a status as one of :running, :failure, :success, or :aborted the core system will run the Behavior Tree&#39;s as defined and handle normal errors with restarts. Users define error handling outside generic BT capabilities. defmodule MyAutomaton do use Automaton, # required # one of :sequence, :selector, :parallel, :action (no children), etc... node_type: :selector, # the heartbeat for this node(subtree), in milliseconds # the default is 50ms (mimics the average human brain perception cycle time) # heartbeat adaption as meta-level(automata) action, to be changed at runtime tick_freq: 50, # 50ms # excluded for execution nodes # list of child control/action(execution) nodes # these run in order for type :selector and :sequence nodes and in parallel # for type :parallel, and in a user-defined dynamic order for :priority children: [ChildAction1, ChildSequence1, ChildAction2] # called every tick, must return status def update do # reactively and proactively change the world # ie.. effect the current environment in phases using either effectors or via communication with other agents {:ok, status} end end Example Below is a simplified hypothetical example of a sequence node(subtree) for an autonomous &quot;Forex Trader&quot;. The first two leafs are condition nodes, and the last two are action nodes. References Actor Model Multi-Agent Meta-Level Control","ref":"readme.html#features","title":"ReadMe - Features","type":"extras"},{"doc":"If available in Hex, the package can be installed by adding Automata to your list of dependencies in mix.exs: def deps do [ {:automata, &quot;~&gt; 0.1.0&quot;} ] end","ref":"readme.html#installation","title":"ReadMe - Installation","type":"extras"},{"doc":"Eric Steen - upstarter See also the list of contributors who participated in this project.","ref":"readme.html#authors","title":"ReadMe - Authors","type":"extras"},{"doc":"This project is licensed under the Apache 2.0 License - see the License.md file for details or","ref":"readme.html#license","title":"ReadMe - License","type":"extras"},{"doc":"","ref":"contributing.html","title":"Contributing","type":"extras"},{"doc":"👍🎉 First off, thanks for taking the time to contribute! 🎉👍 Please reach out to ericsteen1@gmail.com if you have any questions. Welcome to The Automata Project! We are eager for your contributions and very happy you found yourself here! Here are our current needs: Elixir Alchemists with Design, Architecture, OTP Best Practices Expertise AI, Cognitive Architecture &amp; Behavior Tree Expertise ETS, BlackBoard System, Utility AI Expertise Test Coverage Documentation Senior Code Reviewers to ensure Quality Willingness and motivation to learn it all Where to get started contributing A good place to start is in the project kanban. Especially those threads labeled &#39;good first issue&#39;, &#39;testing&#39;. Please join the slack channel and/or reach out to ericsteen1@gmail.com if interested! If in doubt, check the wiki. 🕵️ Definitely check out the Goals on the wiki. This is currently the focal point for the project defining short, medium, and long term problem solving goals across project dimensions. New issues should come from solving these problems &quot;in goal form&quot;. Regular brain-storming and question-storming should be conducted with the end game in mind. See How it works for a high level view of the project, and check out the docs. See Future Directions for more on what&#39;s in the works. Special notes for Automata developers See ex_doc recommendations for documentation guidelines. DEBUGGING NOTE: anytime you see an error or warning that is in one of the mock sequence modules, it probably isn&#39;t. It is probably in one of the modules in core that get injected into them. This is the nature of meta-programming debugging. If anyone with experience debugging a heavily meta-programmed application, please chime in.","ref":"contributing.html#contributing","title":"Contributing - Contributing","type":"extras"},{"doc":"Check the #dev or #testing channels on slack for questions/info. Design Standards Abstraction &amp; Modularity are key. Spend the time and/or Ask on the Slack Channel to find the right abstraction. In terms of modularity, If its more than 10-20 lines, put it in a unit Function, Module or Struct that is tested and named well (by its role in the context if possible, rather than its data type or random name). Meta-programming will be heavily used as this is a framework, but it is important to know where it is useful and where its not. It is wise not to overuse clever meta-programming magic. If your not sure, ask, or use the force Luke (if your a Jedi). Use function pattern matching over for other types of enumeration wherever possible as this is a first-principle in Elixir systems. If your not sure how to do something, rather than do a hack, put a skeleton in place and submit a PR so a more senior engineer can provide guidance. Coding Standards No shortcuts or Rush Jobs. Quality is job #1. We are creating something of very high quality, built to stand the test of time. Strive for 0% technical debt (the best kind of debt). Frameworks are poorly suited to “agile” practices, since they require foresight and a lot of generic capabilities. Today&#39;s emphasis on “agile” development is predicated on the developer&#39;s ignorance of what is required. Frameworks cannot be developed in that manner, since they are generic and devoid of ultimate functionality. They are all about potential, not actual end-user functionality. If you don&#39;t know the best way to do something, ask a core team member, or reach out to the very helpful Elixir community. See the list of resources. Always think about what can go wrong, what will happen on invalid input, and what might fail, which will help you catch many bugs before they happen. PR Review Standards Code Reviews by core team members are required before merging and must be escalated if there is even the slightest concern of a design/logic flaw or incomplete testing. Imagine your building a rocket to mars and putting you and your family on it. Would you commmit that spaghetti code now? Every PR should have test coverage unless it is a trivial change or is approved by 2 core team members or designated reviewers. The BD — upstarter, is a stickler when it comes to architecture, design, code quality, accuracy, comprehensiveness. Be warned the project has very high standards as it must, and feel entirely free to keep him informed of his failures to follow the strict quality requirements. 😉 Don&#39;t take it personally if you receive a communication similar to this when a PR is not up to standards: Apologies, but this work cannot be accepted as it is. Perhaps there is a way it can be improved upon, but as it stands it will not be merged. Testing Standards In Progress. Property Testing? Permutation Testing? Join the conversation on The Automata Project Slack Channel Unit tests test the unit of behavior, not the unit of implementation. Changing the implementation, without changing the behavior or having to change any of your tests is the goal, although not always possible. So where possible, treat your test objects as black boxes, testing through the public API without calling private methods or tinkering with state. Where to ask for help: The Automata Project Slack Channel Elixir Forum Elixir Slack Channel Stack Overflow Reddit Quora Discord Code of Conduct The Blackboard Global Blackboard all nodes share this knowledge store the automata will act upon seeing certain data changes in the global blackboard Individual Node Blackboards node blackboards use protected tables for knowledge sharing – all processes can read, one process has write access the automaton will act upon seeing certain data changes in the global blackboard","ref":"contributing.html#engineering-standards-best-practices","title":"Contributing - Engineering Standards &amp; Best Practices","type":"extras"}]