searchNodes=[{"doc":"","ref":"Activation.html","title":"Activation","type":"module"},{"doc":"","ref":"Automata.html","title":"Automata","type":"module"},{"doc":"Callback implementation for Application.start/2.","ref":"Automata.html#start/2","title":"Automata.start/2","type":"function"},{"doc":"","ref":"Automata.html#start_automata/1","title":"Automata.start_automata/1","type":"function"},{"doc":"","ref":"Automata.html#start_world/1","title":"Automata.start_world/1","type":"function"},{"doc":"","ref":"Automata.html#start_worlds/2","title":"Automata.start_worlds/2","type":"function"},{"doc":"","ref":"Automata.html#status/1","title":"Automata.status/1","type":"function"},{"doc":"","ref":"Automata.ActionSelect.html","title":"Automata.ActionSelect","type":"module"},{"doc":"The Automata.Server starts the individual Automata.AutomatonSupervisor&#39;s under this Supervisor, which handles their lifecycle management. The :one_for_one restart strategy causes each Automata.AutomatonSupervisor to have their lifecycles individally managed (by the Automata.Server) in a decentralized way with no central point of failure.","ref":"Automata.AutomataSupervisor.html","title":"Automata.AutomataSupervisor","type":"module"},{"doc":"","ref":"Automata.AutomataSupervisor.html#child_spec/0","title":"Automata.AutomataSupervisor.child_spec/0","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Automata.AutomataSupervisor.html#child_spec/1","title":"Automata.AutomataSupervisor.child_spec/1","type":"function"},{"doc":"Callback implementation for DynamicSupervisor.init/1.","ref":"Automata.AutomataSupervisor.html#init/1","title":"Automata.AutomataSupervisor.init/1","type":"function"},{"doc":"","ref":"Automata.AutomataSupervisor.html#start_link/1","title":"Automata.AutomataSupervisor.start_link/1","type":"function"},{"doc":"Runs as a child of Automata.AutomataSupervisor and supervises the Automaton.AgentServer which is a delegate for lifecycle management of the user agents and starts the agents under the Automata.AgentSupervisor. This supervisor uses strategy :one_for_all to ensure that errors restart the entire supervision tree including the Automaton.AgentServer.","ref":"Automata.AutomatonSupervisor.html","title":"Automata.AutomatonSupervisor","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Automata.AutomatonSupervisor.html#child_spec/1","title":"Automata.AutomatonSupervisor.child_spec/1","type":"function"},{"doc":"Callback implementation for Supervisor.init/1.","ref":"Automata.AutomatonSupervisor.html#init/1","title":"Automata.AutomatonSupervisor.init/1","type":"function"},{"doc":"","ref":"Automata.AutomatonSupervisor.html#start_link/1","title":"Automata.AutomatonSupervisor.start_link/1","type":"function"},{"doc":"A global Blackboard for knowledge representations Memory and Interaction Protocols With large trees, we face another challenge: storage. In an ideal world, each AI would have an entire tree allocated to it, with each behavior having a persistent amount of storage allocated to it, so that any state necessary for its functioning would simply always be available. However, assuming about 100 actors allocated at a time about 60 behaviors in the average tree, and each behavior taking up about 32 bytes of memory, this gives us about 192K of persistent behavior storage. Clearly, as the tree grows even further this becomes even more of a memory burden, ExUnitially for a platform like the Xbox. We can cut down on this burden considerably if we note that in the vast majority of cases, we are only really interested in a small number of behaviors - those that are actually running (the current leaf, its parent, it grandparent and so on up the tree). The obvious optimization to make is to create a small pool of state memory for each actor divided into chunks corresponding to levels of the hierarchy. The tree becomes a free-standing static structure (i.e. is not allocated per actor) and the behaviors themselves become code fragments that operate on a chunk. (The same sort of memory usage can be obtained in an object oriented way if parent behavior objects only instantiate their children at the time that the children are selected. This was the approach taken in [Alt04]). Our memory usage suddenly becomes far more efficient: 100 actors times 64 bytes (an upper bound on the amount behavior storage needed) times 4 layers (in the case of Halo 2), or about 25K. Very importantly, this number only grows with the maximum depth of the tree, not the number of behaviors. This leaves us with another problem however, the problem of persistent behavior state. There are numerous instances in the Halo 2 repertoire where behaviors are disallowed for a certain amount of time after their last successful performance (grenade-throwing, for example). In the ideal world, this information about &quot;last execution time&quot; would be stored in the persistently allocated grenade behavior. However, as that storage in the above scheme is only temporarily allocated, we need somewhere else to store the persistent behavior data. There is an even worse example - what about per-target persistent behavior state? Consider the search behavior. Search would like to indicate when it fails in its operation on a particular target. This lets the actor know to forget about that target and concentrate its efforts elsewhere. However, this doesn&#39;t preclude the actor going and searching for a different target - so the behavior cannot simply be turned off once it has failed. Memory - in the psychological sense of stored information on past actions and events, not in the sense of RAM - presents a problem that is inherent to the tree structure. The solution in any world besides the ideal one is to create a memory pool - or a number of memory pools - outside the tree to act as its storage proxy. When we consider our memory needs more generally, we can quickly distinguish at least four different categories: Per-behavior (persistent): grenade throws, recent vehicle actions Per-behavior (short-term): state lost when the behavior finishes Per-object: perception information, last seen position, last seen orientation Per-object per-behavior: last-meleed time, search failures, pathfinding-to failures","ref":"Automata.Blackboard.html","title":"Automata.Blackboard","type":"module"},{"doc":"Classification hierarchy (Perception System) Once the stimulus from the world has been “sensed,” it can then be “perceived.” The distinction between sensing and perceiving is important. An agent, for example, may “sense” an acoustic event, but it is up to the perception system to recognize it as an instance of a specific type of acoustic event that has some meaning to the agent. A segment of agents may interpret an UtteranceDataRecord as just another noise, but one should classify the utterance as the word &quot;hello”. Similarly with multicast, unicast, broadcast events. Thus, it is within the Perception System that each agent assigns a unique “meaning” to events in the world. Once the stimulus from the world has been “sensed” it can then be “perceived.” The distinction between sensing and perceiving is important. A agent may “sense” an acoustic event, but it is up to the Perception System to recognize and process the event as something that has meaning to the agent. Thus, it is within the Perception System that “meaning” is assigned to events in the world.","ref":"Automata.Perceptory.html","title":"Automata.Perceptory","type":"module"},{"doc":"MMLC - Meta-MultiLevel Control","ref":"Automata.Reasoning.html","title":"Automata.Reasoning","type":"module"},{"doc":"The World-Agent Division The Sensory System marks the single entry point into an agent from the World. All sensory input from the world must pass through the Sensory System before it can be processed by the rest of the agent&#39;s mind. The primary job of the Sensory System is to act as the enforcer of sensory honesty. As such, it processes each DataRecord so that it appears as it would from the agents point of view. Sometimes that means removing it completely – for example, culling VisualDataRecords outside of the perceptual field – or otherwise transforming it into the appropriate reference frame. Because the Sensory System offers a single entry point, it allows us to provide more or less uniform treatment to the many types of DataRecords that an agent may be called upon to process. Types of sensory data: Network: API calls to third parties API calls from third parties (WebHooks) Data Streams (WebSockets) Local Sys: Local Events Local Memory Stores RAM Local Database ROM The Sensory System is a filter through which all world events (represented by DataRecords) must pass. Unlike its physical equivalents, where any data that passes through is fair game, in Automata the Sensory System plays an active role in keeping the agents virtual sensation honest. In a simulated world, there is potentially much more accessible information than the agent, limited by its sensory apparatus, should be able to sense.","ref":"Automata.Sensory.html","title":"Automata.Sensory","type":"module"},{"doc":"Automata.Server is a behavior which provides decentralized fault tolerance lifecycle management for a collection of user-defined agents. Automata.AutomataSupervisor delegates the logic for starting the user-defined agents (along with their supervisors) to this process to keep the supervisor clean and thus more resilient to failure so it can do its primary job, keeping all the automata alive with the life changing magic of OTP supervision at the helm. This is a primary boundary point between the high level automata control policy layers and the lower level (and highly variant) automaton control policy layers. The configured policies are handled by additional layers TBD. TODO: Automata.Config.Parser to have handler Automata.Types.Typology handle","ref":"Automata.Server.html","title":"Automata.Server","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Automata.Server.html#child_spec/1","title":"Automata.Server.child_spec/1","type":"function"},{"doc":"The automata_config data flow is a key abstraction for meta-level control of the agents. This is a primary internal boundary point, before starting the individual agents one by one. The automaton_config data flow / signals transmitted from this point should be untouched until hitting the Automaton.AgentServer, a key boundary point providing lifecycle and argument interpretation before being expedited to the Automaton to be interpreted at both the builtins and custom built level. The layers pre, post, and in between are TBD, along with design of other potential servers off of the Automaton.AgentSupervisor.","ref":"Automata.Server.html#init/1","title":"Automata.Server.init/1","type":"function"},{"doc":"","ref":"Automata.Server.html#start_link/1","title":"Automata.Server.start_link/1","type":"function"},{"doc":"","ref":"Automata.Server.html#status/1","title":"Automata.Server.status/1","type":"function"},{"doc":"Primary boundary point for initial interpretation, re-organization of automata level control policy in order to determine automaton level control policies. We are transforming from control policy -&gt; control policies using information from the World, including the agent configurations.","ref":"Automata.Server.html#transform_automata_config/1","title":"Automata.Server.transform_automata_config/1","type":"function"},{"doc":"On application start, this supervisor process starts the Automata.AutomataSupervisor and it&#39;s corresponding Server. It is started with strategy :one_for_one to ensure that each Automata.AutomataSupervisor is independently self-healing, thus providing fault tolerance.","ref":"Automata.Supervisor.html","title":"Automata.Supervisor","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Automata.Supervisor.html#child_spec/1","title":"Automata.Supervisor.child_spec/1","type":"function"},{"doc":"Callback implementation for Supervisor.init/1.","ref":"Automata.Supervisor.html#init/1","title":"Automata.Supervisor.init/1","type":"function"},{"doc":"","ref":"Automata.Supervisor.html#start_link/1","title":"Automata.Supervisor.start_link/1","type":"function"},{"doc":"Types are builtin state space representations. Typology is for interpretation of what state space representation to use based on user configuration. Each type has a config/ dir to handle user config parsing and interpretation specific to it&#39;s domain.","ref":"Automata.Types.Typology.html","title":"Automata.Types.Typology","type":"module"},{"doc":"TODO: determine layers and levels of abstraction for builtins and custom support ontology, environs, automata type specific protocols and/or behaviours. Using information from the World, including the agent configurations, initialize the state space representations according to the ontology.","ref":"Automata.Types.Typology.html#call/1","title":"Automata.Types.Typology.call/1","type":"function"},{"doc":"","ref":"Automata.Types.Typology.html#types/0","title":"Automata.Types.Typology.types/0","type":"function"},{"doc":"Global utility decisioning First pass should prioritize automata based on global utility calculations Second pass should coordinate automata in achievement of some global goal","ref":"Automata.Utility.html","title":"Automata.Utility","type":"module"},{"doc":"The world contains environments and automata that operate on/from them. User defined automata state spaces (as distinct from automaton state spaces) and blackboards serve as short term working memory shared by the world&#39;s agents. The further in the supervision tree you get to the Automaton.Types the less information you have about the global situation, and vice versa. Therefore, it will be wise to thoughtfully provide abstractions for robust state space, blackboard, ontological representations, etc. for coordination of interacting agents. The World can also be the source of network calls for the world, called into from running agents Local and/or external databases can provide long term world storage. Usage use Automata.World, # An **Ontology** is for highest level meta representations for a **World**. It # gives us a way to provide shared goals, beliefs, features. Ontological # working memory can be used to describe inter-relations in terms of # perspectives, constraints, environs, stratified classes of objects/agents and # their types, objective predictive representations ontology: [], # The representations describing the world ontology may determine the initial # environment and vice versa, they are dependent and can be mixed and matched. environs: [], # the Automata configured to operate in this world, given the environs # TODO: match (or automatch) the automata to an environ or all environs # perhaps like: `automata: [MockAgent1: :psr, MockRobot1: :dec_pomdp]` # or inferred at automata level policies automata: [MockSeq1]","ref":"Automata.World.html","title":"Automata.World","type":"module"},{"doc":"This is the primary user boundary point control interface to the Automata system. The automaton_config parameters flow from the root through the supervision tree on startup and are interpreted by the Typology system to inject the appropriate modules into the user-defined agents.","ref":"Automaton.html","title":"Automaton","type":"module"},{"doc":"Parses each individual agent config from the user and starts it under the AgentSupervisor.","ref":"Automaton.AgentServer.html","title":"Automaton.AgentServer","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Automaton.AgentServer.html#child_spec/1","title":"Automaton.AgentServer.child_spec/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"Automaton.AgentServer.html#init/1","title":"Automaton.AgentServer.init/1","type":"function"},{"doc":"","ref":"Automaton.AgentServer.html#init/2","title":"Automaton.AgentServer.init/2","type":"function"},{"doc":"","ref":"Automaton.AgentServer.html#start_link/1","title":"Automaton.AgentServer.start_link/1","type":"function"},{"doc":"","ref":"Automaton.AgentServer.html#status/1","title":"Automaton.AgentServer.status/1","type":"function"},{"doc":"","ref":"Automaton.AgentServer.State.html","title":"Automaton.AgentServer.State","type":"module"},{"doc":"Directly supervises the lifecycle of the user-defined agents (behavior trees). The Automaton.AgentServer starts them under this process. It is the parent and root of the user-defined composite, making it the boundary point between the high level Automaton policy control system and the user defined control.","ref":"Automaton.AgentSupervisor.html","title":"Automaton.AgentSupervisor","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Automaton.AgentSupervisor.html#child_spec/1","title":"Automaton.AgentSupervisor.child_spec/1","type":"function"},{"doc":"Callback implementation for DynamicSupervisor.init/1.","ref":"Automaton.AgentSupervisor.html#init/1","title":"Automaton.AgentSupervisor.init/1","type":"function"},{"doc":"","ref":"Automaton.AgentSupervisor.html#start_link/1","title":"Automaton.AgentSupervisor.start_link/1","type":"function"},{"doc":"The “brain” of each agent implemented with Automata is organized into a collection of discrete systems that communicate through an internal blackboard. The Node Blackboard for Individual Agent Postings (OBJECT_OF_ATTENTION, etc.)","ref":"Automaton.Blackboard.html","title":"Automaton.Blackboard","type":"module"},{"doc":"","ref":"Automaton.Reasoning.html","title":"Automaton.Reasoning","type":"module"},{"doc":"Implements the Behavior Tree (BT) state space representation. Behavior trees are a unique combination of state space representation (graphical, or tree) and action-selection decision scheme with plugin variations, where the user can choose or customize the logic for traversal and lifecycle management. Notes: Initialization and shutdown require extra care: on_init: receive extra parameters, fetch data from blackboard/utility, make requests, etc.. shutdown: free resources to not effect other actions TODO: store any currently processing nodes along with any nodes with monitor decorators so when monitors are activated, reactivity is achieved. Use Zipper Tree to store both?","ref":"Automaton.Types.BT.html","title":"Automaton.Types.BT","type":"module"},{"doc":"An action is a leaf in the tree. It operates on the world as a component of a composite(control) node.","ref":"Automaton.Types.BT.Action.html","title":"Automaton.Types.BT.Action","type":"module"},{"doc":"Agent is a function from percept sequences to actions Action Selection, Must be simple and fast Given a set of PerceptMemory objects(structs) that detail the perceived state of the world, the agent must decide which action(s) it is appropriate to perform. This process is known as Action Selection. There are three essential issues to be addressed when designing an Action Selection mechanism. First, what is the fundamental representation of action used by the system? Second, how does the system choose which actions to perform at a given instant? Many types of decision-making processes are possible here. Third, how can the choice of action be modified to allow the agent to learn from experience? ActionGroup = {} ActionTuple = {} fields: trigger - A piece of code that returns a scalar value representing the relevance of an ActionTuple given the current state of Working Memory. Triggers are typically references to percepts in the Percept Tree (a trigger that points to the &quot;Bird Shape” percept will return a high relevance given any PerceptMemory that has a high &quot;Bird Shape” confidence). However, the TriggerContext is general enough that more complex trigger-conditions can be hand-crafted. As we will see, Percept-based triggers are useful because they can be automatically generated through the learning process action - Primitive action to take (usually modify blackboard as event system) object - Target for the Action often defined in terms of percepts When an ActionTuple is active, the ObjectContext posts the PerceptMemory chosen into the OBJECT_OF_ATTENTION posting of the internal blackboard, thereby making it available to the rest of the system. The ObjectContext is an optional component, since not all actions are necessarily targeted do_until - A piece of code that returns a scalar representing the continuing relevance of an ActionTuple while it is active. value - intrinsic value/relevance, an indicator of how generally “good” the ActionTuple is. This is similar to the Q-value in Q-learning (see [Ballard 1997])","ref":"Automaton.Types.BT.ActionSelect.html","title":"Automaton.Types.BT.ActionSelect","type":"module"},{"doc":"An Automaton.Types.BT.Behavior is an abstract interface for composites and components that can be activated, run, and deactivated. Actions(Execution Nodes) provide specific implementations of this interface. Branches in the tree can be thought of as high level behaviors, heirarchically combining smaller behaviors to provide more complex and interesting behaviors. Note: there is a bunch of placeholder stuff in here right now and needs thought and cleanup. The specs for the callbacks are not accurate, just needed something that compiled and ran. Needs more thought and attention as the design process continues.","ref":"Automaton.Types.BT.Behavior.html","title":"Automaton.Types.BT.Behavior","type":"behaviour"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:abort/0","title":"Automaton.Types.BT.Behavior.abort/0","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:aborted?/0","title":"Automaton.Types.BT.Behavior.aborted?/0","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:on_init/1","title":"Automaton.Types.BT.Behavior.on_init/1","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:on_terminate/1","title":"Automaton.Types.BT.Behavior.on_terminate/1","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:reset/0","title":"Automaton.Types.BT.Behavior.reset/0","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:running?/0","title":"Automaton.Types.BT.Behavior.running?/0","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:status/0","title":"Automaton.Types.BT.Behavior.status/0","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:terminated?/0","title":"Automaton.Types.BT.Behavior.terminated?/0","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.Behavior.html#c:update/1","title":"Automaton.Types.BT.Behavior.update/1","type":"callback"},{"doc":"When a component behavior is complete and returns its status code, then the Composite it is a child of decides whether to continue through its children or whether to stop there and then and return a value. Supervised by the Automaton.Types.BT.CompositeServer which is the parent of the component.","ref":"Automaton.Types.BT.ComponentServer.html","title":"Automaton.Types.BT.ComponentServer","type":"module"},{"doc":"","ref":"Automaton.Types.BT.ComponentServer.html#types/0","title":"Automaton.Types.BT.ComponentServer.types/0","type":"function"},{"doc":"Parallel Node When the execution of a parallel node starts, then the node’s children are executed in succession from left to right without waiting for a return status from any child before ticking the next one. It returns success if a given number of children M ∈ N return success, it returns failure when the children that return running and success are not enough to reach the given number, even if they would all return success. It returns running otherwise. The purpose of the parallel node is to model those tasks separable in independent sub-tasks performing non-conflicting actions (e.g. a multi object tracking can be performed using several cameras). We could also configure Parallel to have the policy of the Selector task so it returns success when its first child succeeds and failure only when all have failed. We could also use hybrid policies, where it returns success or failure after some specific number or proportion of its children have succeeded or failed. Using Parallel blocks to make sure that Conditions hold is an important use-case in behavior trees. With it we can get much of the power of a state machine, and in particular the state machine’s ability to switch tasks when important events occur and new opportunities arise. Rather than events triggering transitions between states, we can use sub-trees as states and have them running in parallel with a set of conditions.","ref":"Automaton.Types.BT.Composite.Parallel.html","title":"Automaton.Types.BT.Composite.Parallel","type":"module"},{"doc":"Selector Node (also known as Fallback) When the execution of a selector node starts, the node’s children are executed in succession from left to right, until a child returning success or running is found. Then this message is returned to the parent of the selector. It returns failure only when all the children return a status failure. The purpose of the selector node is to robustly carry out a task that can be performed using several different approaches. A Selector will return immediately with a success status code when one of its children runs successfully. As long as its children are failing, it will keep on trying. If it runs out of children completely, it will return a failure status code.","ref":"Automaton.Types.BT.Composite.Selector.html","title":"Automaton.Types.BT.Composite.Selector","type":"module"},{"doc":"Behavior for user-defined sequence actions. When the execution of a sequence node starts, then the node’s children are executed in succession from left to right, returning to its parent a status failure (or running) as soon as a child that returns failure (or running) is found. It returns success only when all the children return success. The purpose of the sequence node is to carry out the tasks that are deﬁned by a strict sequence of sub-tasks, in which all have to succeed. A Sequence will return immediately with a failure status code when one of its children fails. As long as its children are succeeding, it will keep going. If it runs out of children, it will return in success.","ref":"Automaton.Types.BT.Composite.Sequence.html","title":"Automaton.Types.BT.Composite.Sequence","type":"module"},{"doc":"When a child behavior is complete and returns its status code the Composite decides whether to continue through its children or whether to stop there and then and return a value. The behavior tree represents all possible Actions that your AI can take. The route from the top level to each leaf represents one course of action, and the behavior tree algorithm traverses among those courses of action in a left-to-right manner. In other words, it performs a depth-first traversal.","ref":"Automaton.Types.BT.CompositeServer.html","title":"Automaton.Types.BT.CompositeServer","type":"behaviour"},{"doc":"","ref":"Automaton.Types.BT.CompositeServer.html#c:add_child/1","title":"Automaton.Types.BT.CompositeServer.add_child/1","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.CompositeServer.html#c:clear_children/0","title":"Automaton.Types.BT.CompositeServer.clear_children/0","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.CompositeServer.html#c:continue_status/0","title":"Automaton.Types.BT.CompositeServer.continue_status/0","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.CompositeServer.html#c:remove_child/1","title":"Automaton.Types.BT.CompositeServer.remove_child/1","type":"callback"},{"doc":"","ref":"Automaton.Types.BT.CompositeServer.html#types/0","title":"Automaton.Types.BT.CompositeServer.types/0","type":"function"},{"doc":"The CompositeServer is injected into the user-defined automaton and manages the lifecycle of their children (the execution nodes), ie. starting, stopping, and handling messages. All components are children of a composite.","ref":"Automaton.Types.BT.CompositeSupervisor.html","title":"Automaton.Types.BT.CompositeSupervisor","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Automaton.Types.BT.CompositeSupervisor.html#child_spec/1","title":"Automaton.Types.BT.CompositeSupervisor.child_spec/1","type":"function"},{"doc":"Callback implementation for DynamicSupervisor.init/1.","ref":"Automaton.Types.BT.CompositeSupervisor.html#init/1","title":"Automaton.Types.BT.CompositeSupervisor.init/1","type":"function"},{"doc":"","ref":"Automaton.Types.BT.CompositeSupervisor.html#start_link/1","title":"Automaton.Types.BT.CompositeSupervisor.start_link/1","type":"function"},{"doc":"","ref":"Automaton.Types.BT.Config.html","title":"Automaton.Types.BT.Config","type":"module"},{"doc":"High level automaton_config parsing policy for BT specific user configs.","ref":"Automaton.Types.BT.Config.Parser.html","title":"Automaton.Types.BT.Config.Parser","type":"module"},{"doc":"Determines the node_type given the automaton_config. Returns node_type. Examples iex&gt; automaton_config = [node_type: :selector] iex&gt; Automaton.Config.Parser.node_type(automaton_config) :selector","ref":"Automaton.Types.BT.Config.Parser.html#call/1","title":"Automaton.Types.BT.Config.Parser.call/1","type":"function"},{"doc":"Types are builtin state space representations. Typology is for interpretation of what state space representation to use based on user configuration. Each type has a config/ dir to handle user config parsing and interpretation specific to it&#39;s domain.","ref":"Automaton.Types.Typology.html","title":"Automaton.Types.Typology","type":"module"},{"doc":"","ref":"Automaton.Types.Typology.html#call/1","title":"Automaton.Types.Typology.call/1","type":"function"},{"doc":"","ref":"Automaton.Types.Typology.html#types/0","title":"Automaton.Types.Typology.types/0","type":"function"},{"doc":"Node utility decisioning First pass should prioritize composite &#39;selector&#39; actions based on utility (a priority composite node) Dual Utility Reasoner There are two common approaches to utility-based selection. The first, absolute utility, is to evaluate every option and take the one with the highest utility. The second, relative utility, is to select an option at random, using the utility of each option to define the probability that it will be selected. The probability (P) for selecting an option (O) is determined by dividing the utility (U) of that option by the total utility of all options. This approach is commonly referred to as weight-based random or weighted random. A Dual Utility Reasoner combines both of these approaches. It assigns two utility values to each option: a rank (absolute utility) and a weight (relative utility). Conceptually, rank is used to divide the options into categories, where we only select options that are in the best category. Weight is used to evaluate options within the context of their category. Thus the weight of an option is only meaningful relative to the weights of other options within the same rank category – and only the weights of the options in the best category truly matter","ref":"Automaton.Utility.html","title":"Automaton.Utility","type":"module"},{"doc":"","ref":"AutomatonConfig.html","title":"AutomatonConfig","type":"module"},{"doc":"","ref":"MockSeq1.html","title":"MockSeq1","type":"module"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.abort/0.","ref":"MockSeq1.html#abort/0","title":"MockSeq1.abort/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.aborted?/0.","ref":"MockSeq1.html#aborted?/0","title":"MockSeq1.aborted?/0","type":"function"},{"doc":"","ref":"MockSeq1.html#add_child/1","title":"MockSeq1.add_child/1","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"MockSeq1.html#child_spec/1","title":"MockSeq1.child_spec/1","type":"function"},{"doc":"","ref":"MockSeq1.html#clear_children/0","title":"MockSeq1.clear_children/0","type":"function"},{"doc":"","ref":"MockSeq1.html#continue_status/0","title":"MockSeq1.continue_status/0","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"MockSeq1.html#init/1","title":"MockSeq1.init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_init/1.","ref":"MockSeq1.html#on_init/1","title":"MockSeq1.on_init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_terminate/1.","ref":"MockSeq1.html#on_terminate/1","title":"MockSeq1.on_terminate/1","type":"function"},{"doc":"","ref":"MockSeq1.html#remove_child/1","title":"MockSeq1.remove_child/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.reset/0.","ref":"MockSeq1.html#reset/0","title":"MockSeq1.reset/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.running?/0.","ref":"MockSeq1.html#running?/0","title":"MockSeq1.running?/0","type":"function"},{"doc":"","ref":"MockSeq1.html#schedule_next_tick/1","title":"MockSeq1.schedule_next_tick/1","type":"function"},{"doc":"","ref":"MockSeq1.html#set_status/2","title":"MockSeq1.set_status/2","type":"function"},{"doc":"","ref":"MockSeq1.html#start_children/1","title":"MockSeq1.start_children/1","type":"function"},{"doc":"","ref":"MockSeq1.html#start_link/1","title":"MockSeq1.start_link/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.status/0.","ref":"MockSeq1.html#status/0","title":"MockSeq1.status/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.terminated?/0.","ref":"MockSeq1.html#terminated?/0","title":"MockSeq1.terminated?/0","type":"function"},{"doc":"","ref":"MockSeq1.html#tick/1","title":"MockSeq1.tick/1","type":"function"},{"doc":"","ref":"MockSeq1.html#tick_workers/1","title":"MockSeq1.tick_workers/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.update/1.","ref":"MockSeq1.html#update/1","title":"MockSeq1.update/1","type":"function"},{"doc":"","ref":"MockSeq1.State.html","title":"MockSeq1.State","type":"module"},{"doc":"Used for experimentation and QA testing until testing strategy devised.","ref":"MockWorld1.html","title":"MockWorld1","type":"module"},{"doc":"","ref":"Percept.html","title":"Percept","type":"behaviour"},{"doc":"","ref":"Percept.html#c:update/1","title":"Percept.update/1","type":"callback"},{"doc":"When a DataRecord enters the Perception System, a new PerceptMemory is created, and as the DataRecord is pushed through the Percept Tree, each percept that registers a positive match adds its rExUnittive data to the new PerceptMemory. PerceptMemory can be thought of as Beliefs about the world ( individually and in aggregagte(histories of memories) ) Percepts are organized hierarchically in terms of their specificity. For example, a ShapePercept will activate on the presence of any kind of shape whereas one of its children may activate only on a specific type of shape (e.g. a CircleShapePercept). The children of a percept will receive only the data that was extracted by its parent to process. This hierarchical structure is primarily an efficiency mechanism (no point in testing whether an event is the spoken word “sit” if it has already been determined that the event was not an acoustic one) and is very similar to previous hierarchy-of-sensors approaches. Many percepts are plastic, using statistical models to characterize and refine their response properties. Percepts can modulate their “receptive fields” (the space of inputs to which they will respond positively), and, in concert with the Action System, can modify the topology of the tree itself, dynamically growing a hierarchy of children in a process called innovation. The process of innovation is reward-driven, with only percepts that are believed to be correlated with increasing the reliability of an action in producing a desirable outcome being prompted to innovate. Both the confidence and the extracted data of every percept are cached in a PerceptMemory object. Both the confidence and the extracted data of every percept are cached in a PerceptMemory object. When a DataRecord enters the Perception System, a new PerceptMemory is created, and as the DataRecord is pushed through the Percept Tree, each percept that registers a positive match adds its rExUnittive data to the new PerceptMemory. Thus, given a sensory stimulus, the PerceptMemory represents all the agent can know about that stimulus. Thus, given a sensory stimulus, the PerceptMemory represents all the agent can know about that stimulus. Working Memory Like other agent-control architectures, we use a Working Memory structure whose function mirrors that of the pyschological conception of Working Memory – an object-based memory that contains information about the immediate task or context. The ultimate goal of Working Memory is to provide a sensory history of objects in the world. It is on the basis of these histories that action-decisions will be made, internal credit for reward assigned, motor-movements modulated, etc. Working Memory is a repository for persistent PerceptMemory objects. Taken together, they constitute the agent&#39;s “view” of the world. The PerceptMemory is itself a useful structure. By caching together the various perceptual impressions made by a world event (“the thing that was in front of me was also blue,” blueness and relative location being separate Percepts) they solve (or perhaps avoid) the infamous perceptual binding problem ([Treisman 1998]). They also allow us to submit complex queries to WorkingMemory: “which is the bird that is nearest me?” PerceptMemory objects become even more useful when they incorporate a time dimension with the data they contain. On any one timestep, the PerceptMemory objects that come out of the Perception System will by necessity only contain information gathered in that timestep. However, as events often extend through time, it is possible to match PerceptMemory objects from previous timesteps. Thus a recent visual event may represent only the latest sighting of an object that we have been tracking for some time. A DataRecord representing the utterance comes in from the world, causing certain Percepts in the Percept Tree to activate. The Perception System caches the confidences and data corresponding to these Percepts in a PerceptMemory object. This object then matches itself with the most similar existing PerceptMemory in Working Memory, and adds its data onto the history of data that it maintains. The Working Memory structure is meant to mirror this psychological conception of Working Memory. The Working Memory maintains a list of persistent PerceptMemory objects that together constitute the agent’s “view” of the current context. That “view,” however, is informed by more than just direct perception. Instead, it is a patchwork of perceptions, predictions and hypotheses. Any component of Automata that has something to say about how the world is (or might be) can modify PerceptMemory objects or post new ones. It is on the basis of these objects, whether directly perceived or not, that action-decisions will be made, internal credit for reward will be assigned, motor-movements will be modulated, and so on. When a new DataRecord is pushed through the Percept Tree, each Percept that registers a positive match caches its confidence and data in a table in the PerceptMemory. This PerceptMemory is then passed off to Working Memory. It is then “matched” against existing PerceptMemory objects stored there to determine if it is truly novel, or rather a continuation of an existing PerceptMemory (for example, is it the same red ball as the red ball that we saw an instant ago in the same place). In the case of visual events, matching is done on the basis of shape, or on the basis of location when shape is not enough to disambiguate incoming visual events (as is often the case with two nearby bird). This matching mechanism also allows events of differing modalities to be combined. If there is good indication that an acoustic event and a visual one belong together (for example, they originate in more or less the same region of space) then they may be matched together in Working Memory, presenting both sight and sound information through a single PerceptMemory and thus giving the impression that, for example, it was the shepherd who said, “sit.” In either case, if a match is found, the data from the new PerceptMemory is added to the history being kept in the old one. The new confidence is also added to a history of confidences. On timesteps in which new information for a given Percept is not observed, its confidence level is decayed. The rate of decay is determined in part by the Percept itself (confidence in another agent’s location might decay rapidly without observation, but confidence in its shape probably would not.)","ref":"PerceptMem.html","title":"PerceptMem","type":"behaviour"},{"doc":"","ref":"PerceptMem.html#c:match/1","title":"PerceptMem.match/1","type":"callback"},{"doc":"A Tree of Percepts The Perception System takes the form of a Percept Tree. A Percept is an atomic classification and data extraction unit that models some aspect of the sensory inputs passed in by the Sensory System. Given a DataRecord it returns both a match probability (the BirdPercept will return the probability that a DataRecord represents the experience of seeing a bird) and, if the match is above a threshold, a piece of extracted data (such as body-space coordinates of the bird). The details of how the confidence is computed and what exact data is extracted are left to the individual percept. The percept structure might encapsulate a neural net or it might encapsulate a simple “if … then …else” clause. This freedom of form is one of the keys to making the Perception System extensible, since the system makes no assumptions about what a percept will detect, what type of data it will extract or how it will be implemented.","ref":"PerceptTree.html","title":"PerceptTree","type":"behaviour"},{"doc":"","ref":"PerceptTree.html#c:add_child/1","title":"PerceptTree.add_child/1","type":"callback"},{"doc":"","ref":"PerceptTree.html#c:clear_children/0","title":"PerceptTree.clear_children/0","type":"callback"},{"doc":"","ref":"PerceptTree.html#c:continue_status/0","title":"PerceptTree.continue_status/0","type":"callback"},{"doc":"","ref":"PerceptTree.html#c:remove_child/1","title":"PerceptTree.remove_child/1","type":"callback"},{"doc":"","ref":"Sensor.html","title":"Sensor","type":"module"},{"doc":"","ref":"Seq1.html","title":"Seq1","type":"module"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.abort/0.","ref":"Seq1.html#abort/0","title":"Seq1.abort/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.aborted?/0.","ref":"Seq1.html#aborted?/0","title":"Seq1.aborted?/0","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Seq1.html#child_spec/1","title":"Seq1.child_spec/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"Seq1.html#init/1","title":"Seq1.init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_init/1.","ref":"Seq1.html#on_init/1","title":"Seq1.on_init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_terminate/1.","ref":"Seq1.html#on_terminate/1","title":"Seq1.on_terminate/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.reset/0.","ref":"Seq1.html#reset/0","title":"Seq1.reset/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.running?/0.","ref":"Seq1.html#running?/0","title":"Seq1.running?/0","type":"function"},{"doc":"","ref":"Seq1.html#schedule_next_tick/1","title":"Seq1.schedule_next_tick/1","type":"function"},{"doc":"","ref":"Seq1.html#set_status/2","title":"Seq1.set_status/2","type":"function"},{"doc":"","ref":"Seq1.html#start_link/1","title":"Seq1.start_link/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.status/0.","ref":"Seq1.html#status/0","title":"Seq1.status/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.terminated?/0.","ref":"Seq1.html#terminated?/0","title":"Seq1.terminated?/0","type":"function"},{"doc":"","ref":"Seq1.html#tick/1","title":"Seq1.tick/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.update/1.","ref":"Seq1.html#update/1","title":"Seq1.update/1","type":"function"},{"doc":"","ref":"Seq1.State.html","title":"Seq1.State","type":"module"},{"doc":"","ref":"Seq2.html","title":"Seq2","type":"module"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.abort/0.","ref":"Seq2.html#abort/0","title":"Seq2.abort/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.aborted?/0.","ref":"Seq2.html#aborted?/0","title":"Seq2.aborted?/0","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Seq2.html#child_spec/1","title":"Seq2.child_spec/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"Seq2.html#init/1","title":"Seq2.init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_init/1.","ref":"Seq2.html#on_init/1","title":"Seq2.on_init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_terminate/1.","ref":"Seq2.html#on_terminate/1","title":"Seq2.on_terminate/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.reset/0.","ref":"Seq2.html#reset/0","title":"Seq2.reset/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.running?/0.","ref":"Seq2.html#running?/0","title":"Seq2.running?/0","type":"function"},{"doc":"","ref":"Seq2.html#schedule_next_tick/1","title":"Seq2.schedule_next_tick/1","type":"function"},{"doc":"","ref":"Seq2.html#set_status/2","title":"Seq2.set_status/2","type":"function"},{"doc":"","ref":"Seq2.html#start_link/1","title":"Seq2.start_link/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.status/0.","ref":"Seq2.html#status/0","title":"Seq2.status/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.terminated?/0.","ref":"Seq2.html#terminated?/0","title":"Seq2.terminated?/0","type":"function"},{"doc":"","ref":"Seq2.html#tick/1","title":"Seq2.tick/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.update/1.","ref":"Seq2.html#update/1","title":"Seq2.update/1","type":"function"},{"doc":"","ref":"Seq2.State.html","title":"Seq2.State","type":"module"},{"doc":"","ref":"Seq3.html","title":"Seq3","type":"module"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.abort/0.","ref":"Seq3.html#abort/0","title":"Seq3.abort/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.aborted?/0.","ref":"Seq3.html#aborted?/0","title":"Seq3.aborted?/0","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Seq3.html#child_spec/1","title":"Seq3.child_spec/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"Seq3.html#init/1","title":"Seq3.init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_init/1.","ref":"Seq3.html#on_init/1","title":"Seq3.on_init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_terminate/1.","ref":"Seq3.html#on_terminate/1","title":"Seq3.on_terminate/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.reset/0.","ref":"Seq3.html#reset/0","title":"Seq3.reset/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.running?/0.","ref":"Seq3.html#running?/0","title":"Seq3.running?/0","type":"function"},{"doc":"","ref":"Seq3.html#schedule_next_tick/1","title":"Seq3.schedule_next_tick/1","type":"function"},{"doc":"","ref":"Seq3.html#set_status/2","title":"Seq3.set_status/2","type":"function"},{"doc":"","ref":"Seq3.html#start_link/1","title":"Seq3.start_link/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.status/0.","ref":"Seq3.html#status/0","title":"Seq3.status/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.terminated?/0.","ref":"Seq3.html#terminated?/0","title":"Seq3.terminated?/0","type":"function"},{"doc":"","ref":"Seq3.html#tick/1","title":"Seq3.tick/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.update/1.","ref":"Seq3.html#update/1","title":"Seq3.update/1","type":"function"},{"doc":"","ref":"Seq3.State.html","title":"Seq3.State","type":"module"},{"doc":"","ref":"Seq4.html","title":"Seq4","type":"module"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.abort/0.","ref":"Seq4.html#abort/0","title":"Seq4.abort/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.aborted?/0.","ref":"Seq4.html#aborted?/0","title":"Seq4.aborted?/0","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"Seq4.html#child_spec/1","title":"Seq4.child_spec/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"Seq4.html#init/1","title":"Seq4.init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_init/1.","ref":"Seq4.html#on_init/1","title":"Seq4.on_init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_terminate/1.","ref":"Seq4.html#on_terminate/1","title":"Seq4.on_terminate/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.reset/0.","ref":"Seq4.html#reset/0","title":"Seq4.reset/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.running?/0.","ref":"Seq4.html#running?/0","title":"Seq4.running?/0","type":"function"},{"doc":"","ref":"Seq4.html#schedule_next_tick/1","title":"Seq4.schedule_next_tick/1","type":"function"},{"doc":"","ref":"Seq4.html#set_status/2","title":"Seq4.set_status/2","type":"function"},{"doc":"","ref":"Seq4.html#start_link/1","title":"Seq4.start_link/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.status/0.","ref":"Seq4.html#status/0","title":"Seq4.status/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.terminated?/0.","ref":"Seq4.html#terminated?/0","title":"Seq4.terminated?/0","type":"function"},{"doc":"","ref":"Seq4.html#tick/1","title":"Seq4.tick/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.update/1.","ref":"Seq4.html#update/1","title":"Seq4.update/1","type":"function"},{"doc":"","ref":"Seq4.State.html","title":"Seq4.State","type":"module"},{"doc":"","ref":"SeqComposite1.html","title":"SeqComposite1","type":"module"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.abort/0.","ref":"SeqComposite1.html#abort/0","title":"SeqComposite1.abort/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.aborted?/0.","ref":"SeqComposite1.html#aborted?/0","title":"SeqComposite1.aborted?/0","type":"function"},{"doc":"","ref":"SeqComposite1.html#add_child/1","title":"SeqComposite1.add_child/1","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor.","ref":"SeqComposite1.html#child_spec/1","title":"SeqComposite1.child_spec/1","type":"function"},{"doc":"","ref":"SeqComposite1.html#clear_children/0","title":"SeqComposite1.clear_children/0","type":"function"},{"doc":"","ref":"SeqComposite1.html#continue_status/0","title":"SeqComposite1.continue_status/0","type":"function"},{"doc":"Callback implementation for GenServer.init/1.","ref":"SeqComposite1.html#init/1","title":"SeqComposite1.init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_init/1.","ref":"SeqComposite1.html#on_init/1","title":"SeqComposite1.on_init/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.on_terminate/1.","ref":"SeqComposite1.html#on_terminate/1","title":"SeqComposite1.on_terminate/1","type":"function"},{"doc":"","ref":"SeqComposite1.html#remove_child/1","title":"SeqComposite1.remove_child/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.reset/0.","ref":"SeqComposite1.html#reset/0","title":"SeqComposite1.reset/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.running?/0.","ref":"SeqComposite1.html#running?/0","title":"SeqComposite1.running?/0","type":"function"},{"doc":"","ref":"SeqComposite1.html#schedule_next_tick/1","title":"SeqComposite1.schedule_next_tick/1","type":"function"},{"doc":"","ref":"SeqComposite1.html#set_status/2","title":"SeqComposite1.set_status/2","type":"function"},{"doc":"","ref":"SeqComposite1.html#start_children/1","title":"SeqComposite1.start_children/1","type":"function"},{"doc":"","ref":"SeqComposite1.html#start_link/1","title":"SeqComposite1.start_link/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.status/0.","ref":"SeqComposite1.html#status/0","title":"SeqComposite1.status/0","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.terminated?/0.","ref":"SeqComposite1.html#terminated?/0","title":"SeqComposite1.terminated?/0","type":"function"},{"doc":"","ref":"SeqComposite1.html#tick/1","title":"SeqComposite1.tick/1","type":"function"},{"doc":"","ref":"SeqComposite1.html#tick_workers/1","title":"SeqComposite1.tick_workers/1","type":"function"},{"doc":"Callback implementation for Automaton.Types.BT.Behavior.update/1.","ref":"SeqComposite1.html#update/1","title":"SeqComposite1.update/1","type":"function"},{"doc":"","ref":"SeqComposite1.State.html","title":"SeqComposite1.State","type":"module"},{"doc":"⦿ | Automata | ⦿ ⦿ ⦿ ⦿ Spawn a system of concurrent, distributed, fault tolerant, and highly available intelligent agents for coordinated and/or uncoordinated action in one or many environments with no central point of failure. This project is Open Source.","ref":"readme.html","title":"ReadMe","type":"extras"},{"doc":"The Automata Project combines the state-of-the-art AI control techniques with the latest research in autonomous decentralized systems, providing AI designers a flexible framework for creating valuable emergent properties in product ecosystems. This project is in the Alpha stage and not ready for production systems. We need Contributors to get to 1.0. We are eager for your contributions and very happy you found yourself here! Please join the slack channel and/or reach out to ericsteen1@gmail.com if interested or with any questions. Here are our contributing guidelines and get up to speed on the wiki.","ref":"readme.html#project-mission","title":"ReadMe - Project Mission","type":"extras"},{"doc":"Note: This will be updated often. The direction of the project will change as the work evolves. We welcome any of your thoughts about roadmapping. See the current milestones here.","ref":"readme.html#roadmap","title":"ReadMe - Roadmap","type":"extras"},{"doc":"Testing is currently happening using the mock sequence in worlds/mock_world_1/mock_automata/mock_seq_1.ex. This is currently our canonical example of how to design a behavior tree (one type of Automaton), and eventually communicates with other heterogeneous agents that you define in worlds/&lt;mock_world&gt;/&lt;mock_automata&gt;/&lt;mock_automaton&gt;. Currently, you can run the mock sequence in an iex shell as follows: iex -S mix iex(1)&gt; send(MockSeq1Server, :update) and tests can be run with debugging capabilities as follows: MIX_ENV=test iex -S mix ExUnit spec/unit/core/automaton/behavior_tree/behavior_spec.exs:31 where you are running a specific context/it block containing line 31.","ref":"readme.html#usage","title":"ReadMe - Usage","type":"extras"},{"doc":"Technologies Elixir &amp; OTP provide the primitives for robust concurrent, fault-tolerant, highly available, self-healing distributed systems. The main point of the Erlang model is an application that can be expected to run forever, as stated by the language designer. Talk about unstoppable software! Read more about the many other benefits of Elixir and OTP. Heterogeneous agent types equipped with environment and reasoning components provide scientists and analysts a selection of graphical, reinforcement learning, and percept based agent constellations for a variety of real world environments. How Elixir? Elixir for world class control fault tolerance and distribution, while leveraging inter-operability to compensate for lack of high dimensional function approximation (linear solver) performance without NIF&#39;s: erlport (python) julia + python rust + python The Automata framework has three abstract semantic layers: Environment (State Space Representations) These are the maps of the territory. Without a good map, any adventurer could easily get lost. To fit the information available to the problem at hand, we separate the data structures representing our models into distinct layers with well defined boundaries. Reasoning (Decision Making, Action Selection) All agents have some formulation of action selection, otherwise they would never achieve their goals. To keep agent decision making as decoupled as possible, we introduce a layer which fits the mode of reasoning to the state space. Knowledge (Memory, Local &amp; Global Histories) Interchangeable memory modules across short term working memory, blackboards, and knowledge bases. Read the wiki and/or the docs for more about the technologies underlying Automata. Requirements Autonomy is the capacity of agent(s) to achieve a set of coordinated goals by their own means (without human intervention) adapting to environment variations. It combines five complementary aspects: Perception e.g. interpretation of stimuli, removing ambiguity/vagueness from complex input data and determining relevant information based on context/strata/motif specific communications Reflection e.g. building/updating a faithful environment run-time model Goal management e.g. choosing among possible goals the most appropriate ones for a given configuration of the environment model Planning to achieve chosen goals Self-adaptation e.g. the ability to adjust behavior through learning and reasoning and to change dynamically the goal management and planning processes. Note that the five aspects are orthogonal. The first two aspects deal with “understanding” the map of the environment. The third and the forth aspects deal with autonomy of decision. Self adaptation ensures adequacy of decisions with rExUnitt to the environment map. See MMLC2. A system is defined as an Autonomous Decentralized System (ADS) if the following two properties are satisfied: Autonomous Controllability: Even if any subsystem fails, is repaired, and/or is newly added, the other subsystems can continue to manage themselves and function. Autonomous Coordinability: Even if any subsystem fails, is repaired, and/or is newly added, the other subsystems can coordinate their individual objectives among themselves and can function in a coordinated fashion.","ref":"readme.html#implementation-overview","title":"ReadMe - Implementation Overview","type":"extras"},{"doc":"Functional Features User Defined Agents Planned builtin and/or custom third-party agent types include: Graphical Model Based Behavior Trees Informed Search Generalized Probabilistic Models Bayesian Networks Reinforcement Learning Based mdp, pomdp, dec-pomdp deep learning Cognitive / Percept Based c4 style percepts A Concurrent, Scalable Blackboard Knowledge System The central problem of artificial intelligence is how to express the knowledge needed in order to create intelligent behavior. — John McCarthy, M.I.T/Stanford Professor, Creator of Lisp A global blackboard that can coordinate automata without being a central point of failure. Individual automaton blackboards readable by all automata, writeable by owning automaton Meta Level Control Meta-level control to support agent interaction, any potential network reorganization. Meta-level control is the ability of an agent to optimize its long term performance by choosing and sequencing its deliberation and execution actions appropriately. 2 Neuromorphic Computing potentially bringing the code to the data rather than the other way around. Performance Features Learn more about the performance features of Automata Applications Trading Systems Patient Monitoring &amp; Care Systems Pandemic Testing Drone Units Swarm Intelligence / Distributed Robotics Intelligent agents with soft realtime multi-dimensional sensory, perception, intuition, and action capabilities Multi-Agent Reinforcement Learning Mixture of Experts Deep Learning Control Systems (python inter-op with erlport) Blockchain Smart Contract Systems A Mega-constellation of satellites 3D Printing and Factory Automation Product Analytics Systems Augmented, Virtual, Mixed Reality Smart Home / IOT Systems High-Speed Rail Systems (Japan has an ADS railway that learns) Chatbot &amp; Game AI&#39;s (esp. MMOG user/npc backends) QA Testing (BT&#39;s are particularly suited to combinatorial testing) ? (choose your adventure) API defmodule MyAutomaton do use Automaton, # required type: :behavior_tree, # the remainder are required with type :behavior_tree. node_type: :selector, # the heartbeat for this node(subtree), in milliseconds # the default is 50ms (mimics the average human brain perception cycle time) # heartbeat adaption as meta-level(automata) action, to be changed at runtime tick_freq: 50, # 50ms # excluded for execution nodes # list of child control/action(execution) nodes # these run in order for type :selector and :sequence nodes and in parallel # for type :parallel, and in a user-defined dynamic order for :priority children: [ChildAction1, ChildSequence1, ChildAction2] @doc &quot;&quot;&quot; Required with `type: :behavior_tree` - Called every tick, must return `{:ok, status}` or `{:error, reason}` ## Reactively and Proactively Change the World &gt; ie.. effect the current environment in phases using either *effectors* or via *communication* with other agents and/or internal/external systems &quot;&quot;&quot; def update do {:ok, status} end end Example Below is a simplified hypothetical example of a :behavior tree sequence control node(subtree) for an autonomous &quot;Forex Trader&quot;. The first two leafs are condition nodes, and the last two are action nodes. References Multi-Agent Meta-Level Control","ref":"readme.html#features","title":"ReadMe - Features","type":"extras"},{"doc":"If available in Hex, the package can be installed by adding Automata to your list of dependencies in mix.exs: def deps do [ {:automata, &quot;~&gt; 0.1.0&quot;} ] end","ref":"readme.html#installation","title":"ReadMe - Installation","type":"extras"},{"doc":"Eric Steen - upstarter See also the list of contributors who participated in this project.","ref":"readme.html#authors","title":"ReadMe - Authors","type":"extras"},{"doc":"This project is licensed under the Apache 2.0 License - see the License.md file for details or","ref":"readme.html#license","title":"ReadMe - License","type":"extras"},{"doc":"","ref":"contributing.html","title":"Contributing","type":"extras"},{"doc":"👍🎉 First off, thanks for taking the time to contribute! 🎉👍 Please reach out to ericsteen1@gmail.com if you have any questions. Welcome to The Automata Project! We are eager for your contributions and very happy you found yourself here! Here are our current needs: Elixir Alchemists &amp; Mad Scientists with Design, Architecture, Scalable OTP Best Practices Expertise AI, Cognitive Architecture &amp; Behavior Tree Expertise ETS, Reinforcement Learning, BlackBoard Systems, &amp; Utility AI Expertise Test Coverage Documentation Senior Code Reviewers to ensure Quality Willingness and motivation to learn it all Where to get started contributing A good place to start is in the project kanban. ExUnitially those threads labeled &#39;good first issue&#39;, &#39;testing&#39;. Please join the slack channel and/or reach out to ericsteen1@gmail.com if interested! If in doubt, check the wiki. 🕵️ Definitely check out the Goals on the wiki. This is currently the focal point for the project defining short, medium, and long term problem solving goals across project dimensions. New issues should come from solving these problems &quot;in goal form&quot;. Regular brain-storming and question-storming should be conducted with the end game in mind. See How it works for a high level view of the project, and check out the docs. See Future Directions for more on what&#39;s in the works. Special notes for Automata developers See ex_doc recommendations for documentation guidelines. DEBUGGING NOTE: anytime you see an error or warning that is in one of the mock sequence modules, it probably isn&#39;t. It is probably in one of the modules in core that get injected into them. This is the nature of meta-programming debugging. If anyone with experience debugging a heavily meta-programmed application, please chime in.","ref":"contributing.html#contributing","title":"Contributing - Contributing","type":"extras"},{"doc":"Check the #dev or #testing channels on slack for questions/info. Design Standards Abstraction &amp; Modularity are key. Spend the time and/or Ask on the Slack Channel to find the right abstraction. In terms of modularity, If its more than 10-20 lines, put it in a unit Function, Module or Struct that is tested and named well (by its role in the context if possible, rather than its data type or random name). Meta-programming will be heavily used as this is a framework, but it is important to know where it is useful and where its not. It is wise not to overuse clever meta-programming magic. If your not sure, ask, or use the force Luke (if your a Jedi). Use function pattern matching over for other types of enumeration wherever possible as this is a first-principle in Elixir systems. If your not sure how to do something, rather than do a hack, put a skeleton in place and submit a PR so a more senior engineer can provide guidance. Coding Standards No shortcuts or Rush Jobs. Quality is job #1. We are creating something of very high quality, built to stand the test of time. Strive for 0% technical debt (the best kind of debt). Frameworks are poorly suited to “agile” practices, since they require foresight and a lot of generic capabilities. Today&#39;s emphasis on “agile” development is predicated on the developer&#39;s ignorance of what is required. Frameworks cannot be developed in that manner, since they are generic and devoid of ultimate functionality. They are all about potential, not actual end-user functionality. If you don&#39;t know the best way to do something, ask a core team member, or reach out to the very helpful Elixir community. See the list of resources. Always think about what can go wrong, what will happen on invalid input, and what might fail, which will help you catch many bugs before they happen. PR Review Standards Code Reviews by core team members are required before merging and must be escalated if there is even the slightest concern of a design/logic flaw or incomplete testing. Imagine your building a rocket to mars and putting you and your family on it. Would you commmit that spaghetti code now? Every PR should have test coverage unless it is a trivial change or is approved by 2 core team members or designated reviewers. The BD — upstarter, is a stickler when it comes to architecture, design, code quality, accuracy, comprehensiveness. Be warned the project has very high standards as it must, and feel entirely free to keep him informed of his failures to follow the strict quality requirements. 😉 Don&#39;t take it personally if you receive a communication similar to this when a PR is not up to standards: Apologies, but this work cannot be accepted as it is. Perhaps there is a way it can be improved upon, but as it stands it will not be merged. Testing Standards In Progress. Property Testing? Permutation Testing? Join the conversation on The Automata Project Slack Channel Unit tests test the unit of behavior, not the unit of implementation. Changing the implementation, without changing the behavior or having to change any of your tests is the goal, although not always possible. So where possible, treat your test objects as black boxes, testing through the public API without calling private methods or tinkering with state. Where to ask for help: The Automata Project Slack Channel Elixir Forum Elixir Slack Channel Stack Overflow Reddit Quora Discord Code of Conduct The Blackboard Global Blackboard all nodes share this knowledge store the automata will act upon seeing certain data changes in the global blackboard Individual Node Blackboards node blackboards use protected tables for knowledge sharing – all processes can read, one process has write access the automaton will act upon seeing certain data changes in the global blackboard","ref":"contributing.html#engineering-standards-best-practices","title":"Contributing - Engineering Standards &amp; Best Practices","type":"extras"}]